# 变量类型
JavaScript变量类型分为值类型和引用类型

## 值类型
数字，字符串，布尔，symbol, undefined

## 引用类型
对象(数组，函数，null)

## 值类型和引用类型的区别
1. 声明变量时内存分配不同
* 值类型：存储在栈中，因为值类型占据空间是固定的，将他们存在较小的内存中-栈中，这样便于迅速查询变量的值
* 引用类型：存在堆中，栈中存储的变量，只是用来查找堆中的引用地址。引用类型值的大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。相反，放在变量的栈空间中的值是该对象存储在堆中的地址。地址的大小是固定的，所以把它存储在栈中对变量性能无任何负面影响

2. 不同的内存分配带来不同的访问机制
在javascript中是不允许直接访问保存在堆内存中的对象的，所以在访问一个对象时，首先得到的是这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，而值类型的则是可以直接访问到的。

3. 复制变量时的不同
1）值类型：在将一个保存着值类型的变量复制给另一个变量时，会将值类型值的副本赋值给新变量，此后这两个变量是完全独立的，他们只是拥有相同的值而已。
2）引用类型：在将一个保存着对象内存地址的变量复制给另一个变量时，会把这个内存地址赋值给新变量，也就是说这两个变量都指向了堆内存中的同一个对象，他们中任何一个作出的改变都会反映在另一个身上。（这里要理解的一点就是，复制对象时并不会在堆内存中新生成一个一模一样的对象，只是多了一个保存指向这个对象指针的变量罢了）

4. 参数传递的不同（把实参复制给形参的过程）
明确一点：ECMAScript中所有函数的参数都是按值来传递的。
　　1）值类型：只是把变量里的值传递给参数，之后参数和这个变量互不影响。
　　2）引用类型：对象变量它里面的值是这个对象在堆内存中的内存地址，因此它传递的值也就是这个内存地址，函数内部对这个参数的修改会影响外部传入的参数本身，因为它们都指向同一个对象。

## 类型转换
1. 强制类型转换

2. 隐式类型转换
```javascript
const a = 100 + 10 // 110
const b = '100' + 10 // 10010
const c = true + '10' // 'true10'
100 = '100' // true
0 == '' // true
false == '' // true
null == undefined // true
// 这里两个!!是表示获取变量如果变为布尔类型，应该是true还是false
!!a === true
!!b === true
!!NaN === false
!!0 === false
!!'' === false
// 注意&&以及||运算符
console.log(100 && 0) // 0
console.log(0 && 100) // 0
console.log(100 || 0) // 100
console.log(0 || 100) // 100
```
### 注意
没有必要死记类型转换规则，有个技巧，一般除了和null判断时用 ==，其余一律使用 ===
```javascript
// 等价于 if (a === null || a === undefined) {}
if (a == null) {}
```
## 相关问题
1. typeof可以判断的类型
可以识别所有值类型
可以识别函数
无法细分其它引用类型（object）
2. === 和 == 的区别
==用于一般比较，===用于严格比较，==在比较的时候可以转换数据类型，===严格比较，只要类型不匹配就返回false
3. 实现深拷贝
```javascript
function deepClone (obj) {
    if (typeof obj !== 'object' || obj == null) {
        return obj
    }
    let res
    if (Array.isArray(obj)) {
        res = []
    } else {
        res = {}
    }
    for (key in obj) {
        if (obj.hasOwnProperty(key)) {
            res[key] = deepClone(obj[key])
        }
    }
    return res
}
```
